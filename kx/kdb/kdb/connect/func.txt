ksql can be extended with k (and dynamically loaded C) e.g.

signum:{(x>0)-x<0}

functions are called on entire columns (overhead <1 microsecond)
[this allows us to write scalar functions AND vector functions --
aggregators(sum...), integrals(sums...) and derivatives(deltas...)] 

functions that just work on atoms have to use 'each', e.g.

ss:{*_ss[x;$y],#x:$x}'  / in x find first y

ssr:{`$_ssr[$x;$y;$z]}' / in x replace y with z

there are two cases.

0. scalar functions, e.g. strlen signum ...

the simplest way to write the scalar functions is to write
the scalar case and use EACH(').

\strlen:{[x]#$x}'	/ use '
\signum:{(x>0)-x<0}	/ here we write the general case

or in util.c: (see http://kx.com/a/k/connect/c/CandK.txt)

K strlen1(K x){return x->t!=4?kerr("should be sym"):gi(strlen(Ks(x)));}
K signum1(K x){return x->t!=1?kerr("should be int"):gi(Ki(x)<0?-1:Ki(x)>0);}

strlen1:("util.so"2:("strlen1";1))'  / use '
signum1:("util.so"2:("signum1";1))'  / use '

1. vector functions, e.g. isum isums ...

\isum:{[x]+/x} / integer sum
\isums:{[x]+\x} / integer sums

in util.c:
K isum1(K x){int i,s=0;if(x->t!=-1)return kerr("should be integer list");
 for(i=0;i<x->n;++i)s+=KI(x)[i];return gi(s);}

K isums1(K x){int i,s=0;K r;if(x->t!=-1)return kerr("should be integer list");
 for(r=gtn(-1,x->n),i=0;i<x->n;++i)s=KI(r)[i]=s+KI(x)[i];return r;}

isum1:"util.so"2:("isum1";1)
isums1:"util.so"2:("isum1";1)
