> How does Kdb handle contention?


there is no contention.
there is no deadlock.


kdb (unlike traditional rdbms) sorted/indexed column store 
practically eliminates random disk access which means the
cpu is almost never blocked.


therefore each kdb process can afford to be single threaded.
thus trivially implementing transaction-serializable and
eliminating contention and deadlock.


[the traditional rdbms is stored by record - has poor
 data locality and encourages the dba to spread
 records all over so that multiple disk drives can work
 somewhat in parallel. we do the opposite -- and get much
 higher performance.


 kdb gets high memory hit rates (good locality) and
 when it does go to disk it is usually to get a lot of
 (nearly) sequential data.


 e.g. one kx customer's 50GB kdb database has multiple processes
 sharing 1 to 2GB of ram. yet has very high(>90%) memory hit rate.


 select price,duration,convexity,... from t 
  where security in bondindex6000, date.month='2000M01'


 has near optimal density.


 and when it goes to disk it gets an entire column chunk.


 even if there is very little real memory,
 one random disk access per column(e.g. 12) is vastly superior to 
 one random disk access per record(e.g. 120,000 = 6000 instruments over 20 days)]


> Does kdb lock at a table, row or block level?


locks are obviated.


> Can multiple users hammer on the same table/database simultaneously?


yes - from the user point of view. of course the cpu is serial.


we can use multiple cpu's by having multiple reader/processes on 
mapped shared or replicated databases. several kx customers do this.


each kdb process can handle several thousand simultaneous open 
connections to a database.
(limited by the number of allowed file descriptors in the host O/S.)
there is no limit to the number of simultaneous web/http users.


> Does Kdb have a mechanism that keeps track (logs) all activity on tables
> such as who, what time and what kind of change done?


yes.


the kdb update log is (timestamp;user;operation)
which can be replayed to any point in time.


kdb start/restart/recovery is simply map&play the log.
(at several hundred thousand to several million updates per second.)




NOTE: kdb versus multithread/rdbms X


suppose 1000 users simultaneously execute a kdb .01 second query.


kdb average response time is 5 seconds.


X average response time:


A. 10 seconds if X is as fast as kdb and has no multi-threading overhead.


B. minutes/hours if X is 10 to 100 times slower than kdb and has overhead.


and how many will deadlock/rollback?


multithread is no panacea.


