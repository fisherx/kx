PARALLEL

parallel/partition databases are used when the big table(s) have
more than 33 million rows. e.g. the tick databases have 10 billion
and are currently growing at 20 million per day.

a parallel database is a directory d with:
 small tables(up to 100MB)          e.g. 'd'save'a'
 splay tables(up to 33million rows) e.g. 'd'rsave'b'
 and parallel tables,               e.g. 'd/20021020'rsave'c'
the parallel directories must be 0,1,2,... or yyyymmdd, yyyymm, yyyy.
(date/month/year partitions are recognized in the first 'where' clause
and a date/month/year column should be in the table to support 'select'.)

parallel tables should have about the same size among partitions.
parallel and splay tables must be fully enumerated.
i.e. varchar is integer index into small keyed table or unique symbol list.
e.g. sex:`male`female;t.sex:0 1 1 0 1;t.sex..T:`sex
updates require scripts. -l logging does not work.


QUERIES

ksql only. queries on the parallel tables must be of the form:

[n{first|last}]select{[u's|a's[by u's]]|distinct u}from t where ...

u's are uniform, e.g. f,f+2,...
a's are uniform of aggr of uniform, e.g. max(x+y)-min(x)
aggrs are count,[x]sum,prd,min,max,[x]avg,last,first,
      variance,deviation,covariance,correlation,median

subqueries and joins are within the partitions(or the shared tables)

see http://kx.com/a/ktaq/q.t for examples.

date, month or year partitions are recognized in the first clause.
every table can have a sorted grouped index, e.g. 'sym'asc'trade';'sym'index'trade'
these enable one disk seek, e.g. select price from t where date=..,sym=..

tables up to 200 million rows can also have one non-sorted grouped index, e.g.
'date'asc'daily';'date'index'daily';'sym'index'daily'
http://kx.com/a/kdb/examples/daily.t

sample build scripts: 
http://kx.com/a/kdb/examples/daily.t
http://kx.com/a/kdb/examples/census.t
(the big tables: person/house/tract are spread across directories 0,1,2,3.
 the non-partitioned tables are shared.)

SMP(-S slaves)

1. partition: k db census.t
2. run: k db k/census -S 2 -p 2001 -P 2080

the partitions should be small enough to avoid swapping scratch space.
i.e. massive sequential read is painless - random dirty write hurts.
e.g. 2 procs running on a single cpu with 256MB have 100MB scratch each.
 100MB can handle SELECT ... BY ... WHERE ... on 2.5 million rows.
 kdb does multi-dimensional aggregation at about 50MB/sec per cpu. 
 if we have disk arrays that read 50MB/sec then the amount of memory
 is irrelevant as long as it spans the partition column manipulations.

DISTRIBUTED(*.m)

0. k -i 2035    on all machines(daemons for starting processes)
1. partition data on all machines, e.g. k db census.t
2. k db census.m -p 2001 -P 2080

http://kx.com/a/kdb/examples/census.m

*.m is a space delimited file of machines, directories and slaves.
the first machine must be localhost.
the other machines must have a k -i 2035 daemon.
test/time single machine (as SMP above).
i.e. query on single machine should take the same time as all machines.

NOTES
scaling with more cpu's is near perfect for queries that span partitions.
use the webviewer. the kdbviewer only sees the first partition.
partition can be useful for a single cpu, i.e.
small partitions reduce memory usage and allow unlimited tables.

we can start the database with n slaves:(round-robin assigned partitions)

>k db d -S n

but how effective this is (i.e. how little contention) depends
on the queries, file system memory and layout.
we can guarantee no contention (and near perfect speedups) by
putting partitions in different physical drives listed in d/par.txt
then the slaves are round-robin allocated drives.
(and the number of drives must be a multiple of the slaves.) 
the number of slaves should be roughly twice the number of cpu's.
(while 1 process is reading from disk -- the other is aggregating.)
 