k2.2 5/24 release notes

major NEW extensions
1. compiling runtime applications(.kr's)
2. read/write gigabyte flatfiles(...1: ...5:)
3. new math: _dot _mul _inv _arcsin ... _sinh ...

major NUC
1. kr.exe can only run .kr's
2. VALUE ERROR is back

NEW

to make runtime scripts
\kr f		makes f.kr from f.k (locked functions)
\l f		tries for f.k then f.kr (to test \l f.kr)
.kr's are stamped with version
k can only load earlier version .kr's

more powerful IPC, e.g.
handle 4:(`"{x+y}";2 3)

prototype formatting
..f run on prototypes of empty columns of tables

amend empty with nothing preserves type
@[!0;!0;::]

faster gui
dependencies in a form only get updated when mapped.

0n sorting
0n's at the beginning

to escape early from .k script 
\

math
_dot	dot product			+/*
_mul	matrix multiply		_dot\:
_inv	matrix inverse		
_arcsin _arccos _arctan _sinh _cosh _tanh

ascii load(textfile) is NT(\r\n) sensitive
("...";...)0:... doesn't need spacer for \r

binary load
("...S...";...)1:... removes blanks
("...IF...";...)1:...	can process ascii

debug
variables in compile context(\d)

to copy in complex objects
2:`f 		/ maps,copies,unmaps

for processing big data in chunks.

 read:
 (t;w)0:(f;start;length)
 (t;w)1:(f;start;length)

 write:(append)
 `f 5:type -1 -2 -3 -4

NUC
 parse-time value errors are back.
 no variable instantiation side-effects.

 .`foo	is still _n
 ."foo"	is value error

FIX
 v\x iterates until repeat of first or last(instead of #v times)	
 NT-IPC race condition on multi-processor with many clients connecting at once
 NT`f 1: ... should not write to a file that is mapped(possible error in k2.1)
 0I#2 check for wsfull
 gui nested dependency update on screen(certain situation was dropped)
 downgrade compare on big integers whose difference overflows 32 bits.

NT and UNIX differ on file write(1:)

 NT cannot delete or truncate a file that is mapped.
 NT can extend a mapped file(at least locally - so 5: is ok).
 (UNIX will disconnect the name from the mapping.)
 if your app allows loading and saving - 
 use 2:`f for load and `f 1: for save.
  
 e.g. `f 1:1:`f will not work if f has a type -1,-2,-3 in it.
 `f 1:||1:`f will work for non-nested -1,-2,-3(ref count release)

 bottom line: NT 1:`f is for read-only data.